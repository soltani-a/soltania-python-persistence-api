from typing import Type, TypeVar, Optional, List, Any, Union
from gremlin_python.driver.driver_remote_connection import DriverRemoteConnection
from gremlin_python.process.anonymous_traversal import traversal
from gremlin_python.process.graph_traversal import __
from gremlin_python.process.traversal import T  # Crucial for accessing T.id or T.label

from soltania_persistence.core.interfaces import EntityManager
from soltania_persistence.core.domain import BaseEntity, Relationship

# Define a generic type E bound to BaseEntity
E = TypeVar("E", bound=BaseEntity)

class GremlinEntityManager(EntityManager):
    def __init__(self, url: str):
        self.url = url
        # Initialize Gremlin connection
        # 'g' is the standard traversal source name
        self.connection = DriverRemoteConnection(url, 'g')
        self.g = traversal().withRemote(self.connection)

    def close(self):
        """Closes the connection to the Gremlin server."""
        self.connection.close()

    def persist(self, entity: E) -> E:
        """
        Saves an entity (Vertex) to the Graph DB.
        Handles both object-based and dictionary-based responses from the driver.
        """
        label = entity.__label__
        
        # Start traversal: create a new Vertex with the specific label
        t = self.g.addV(label)
        
        # Add properties from the Pydantic model
        # We exclude 'id' because it is generated by the DB
        data = entity.model_dump(exclude={"id"}, exclude_none=True)
        
        for key, value in data.items():
            t = t.property(key, value)
            
        try:
            # Execute the query
            result = t.next()
            
            # --- ROBUST ID EXTRACTION ---
            # Case 1: Driver returns a Vertex object (access via attribute)
            if hasattr(result, 'id'):
                entity.id = result.id
            
            # Case 2: Driver returns a Dictionary/Map (access via .get())
            elif isinstance(result, dict):
                # Try T.id (Enum) first, then string 'id' as fallback
                entity.id = result.get(T.id, result.get('id'))
            
            else:
                print(f"⚠️ Warning: Unknown result type in persist: {type(result)}")
            # -----------------------------
                
            return entity
            
        except Exception as e:
            print(f"❌ Error persisting {label}: {e}")
            raise e

    def find_by_property(self, entity_class: Type[E], property_name: str, value: Any) -> Optional[E]:
        """
        Finds a single entity by a specific property (e.g., name, email).
        """
        label = entity_class.__label__
        try:
            # Use elementMap() to fetch all properties and the ID in one go
            result = self.g.V().hasLabel(label).has(property_name, value).elementMap().next()
            
            if not result:
                return None
                
            # Extract ID
            obj_id = result.get(T.id, result.get('id'))
            
            # Clean dictionary for Pydantic (remove T.id, T.label keys)
            clean_data = {k: v for k, v in result.items() if isinstance(k, str)}
            
            # Rehydrate entity
            entity = entity_class(**clean_data)
            entity.id = obj_id
            return entity
            
        except StopIteration:
            # Gremlin throws StopIteration when no result is found
            return None
        except Exception as e:
            print(f"Error finding {label}: {e}")
            return None

    def create_relationship(self, from_entity: BaseEntity, to_entity: BaseEntity, relationship: Relationship):
        """
        Crée une arête (Edge) entre deux sommets.
        Correction : Utilisation de .to() (sans underscore) car 'to' n'est pas réservé en Python.
        """
        if not from_entity.id or not to_entity.id:
            raise ValueError("Entities must be saved before creating relationship")

        label = relationship.__label__
        
        # --- CORRECTION ICI ---
        # 1. V(start) : Point de départ
        # 2. addE(label) : Création de l'arête
        # 3. to(target) : Cible (Attention: .to() et non .to_())
        t = self.g.V(from_entity.id).addE(label).to(__.V(to_entity.id))
        
        # Ajout des propriétés (poids, distance...)
        data = relationship.model_dump(exclude_none=True)
        for key, value in data.items():
            t = t.property(key, value)
            
        try:
            t.next()
        except Exception as e:
            print(f"Error creating relationship: {e}")
            raise e
            
    def clear_database(self):
        """
        DANGER: Deletes all vertices and edges in the database.
        Useful for testing or resetting the environment.
        """
        try:
            self.g.V().drop().iterate()
        except Exception as e:
            print(f"Error clearing DB: {e}")